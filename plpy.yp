# A modified version of perly.y taken from perl's source
#   list of all required functions
#   print, printf, chomp, split, join, exit, push, pop, shift, scalar
#   unshift, reverse, open, close, sort BLOCK LIST, keys, return,
#   ^(\/[^/]*\/)|(s\/[^/]*\/[^/]*\/)

%{
sub getToken {
    my $uni = "chomp|exit|pop|shift|scalar|close|keys";
    my $lop = "print|printf|split|join|push|unshift|reverse|open|sort";
    my @tokens = (
        # matches a string with double or escaped quotes 
        ["STRING", qr/"(?:\\"|""|\\\\|[^"]|)*"/],
        # matches matching functions split (/foo/, $bar)
        ["PMFUNC", qr/split(?=\s*\(\s*\/)/],
        #matches all functions with brackets
        ["FUNC", qr/\w+(?=\s*\()/a],
        ["FUNC1", qr/(?:${uni})(?=\s*\()/],
        ["UNIOP", qr/(?:${uni})(?!\s*\()/],
        ["LSTOP", qr/(?:${lop})/],
        ["COMMENT", qr/\#.*/],
        ["FOR", qr/for|foreach/],
        ["WHILE", qr/while/],
        ["ELSIF", qr/elsif/],
        ["ELSE", qr/else/],
        ["CONTINUE", qr/next/],
        ["LOOPEX", qr/last/],
        ["ANDOP", qr/and/],
        ["NOTOP", qr/not/],
        ["SUB", qr/sub/],
        ["IF", qr/if/],
        ["MY", qr/my/],
        ["OROP", qr/or/],
        ["DOTDOT", qr/\.\.\.?/],
        ["EQOP", qr/==|!=|eq/],
        ["ANDAND", qr/&&/],
        ["MATCHOP", qr/=~/],
        ["POWOP", qr/\*\*/],
        ["POSTINC", qr/\+\+/],
        ["POSTDEC", qr/--/],
        ["DOLSHARP", qr/\$#/],
        ["ASSIGNOP", qr/=|\.=/],
        ["ADDOP", qr/[\+\.-]/],
        ["RELOP", qr/>|<|<=|>=|lt|gt|le|ge/],
        ["MULOP", qr/[\/%\*]/],
        ["OROR", qr/\|\|/],
        [",", qr/,/],
        ["!", qr/!/],
        [")", qr/\)/],
        ["(", qr/\(/],
        ["{", qr/\{/],
        ["}", qr/\}/],
        [";", qr/;/],
        ["[", qr/\[/],
        ["]", qr/\]/],
        ["&", qr/&/],
        ["@", qr/@/],
        ["%", qr/%/],
        ["\$", qr/\$/],
        ["WORD", qr/\w+/a]
    );

    $_[0]->YYData->{"DATA"} =~ s/^\s+//;
    print "___Remaining___\n", $_[0]->YYData->{"DATA"}, "\n";#_______________\n" ;
    my @length;
    #foreach my $item (@tokens){
    #   my ($a, $b) = @$item;
    #   print "$a, $b\n";
#}
    my $found = 0;
    for (my $i; $i < scalar @tokens; $i++){
        my $token = $tokens[$i][0];
        my $re = $tokens[$i][1];
        $length[$i] = 0;
        if ($_[0]->YYData->{"DATA"} =~ /^${re}/){
            $found = 1;
            @length[$i] = length($&);
            #print "Found match ($token): ($&), $length[$i]\n";
        }
        #print "$token, $re\n";
    }

    if ($found){
        my $maxpos = 0; 
        my $maxval = 0;
        for (my $i = 0; $i < scalar @tokens; $i++){
            if ($length[$i] > $maxval){
                $maxpos = $i;
                $maxval = $length[$i];
            }
        }
#for (my $i=scalar @length -1; $i >= 0; $i--){
#   if ($length[$i] => $maxval){
#        $maxpos = $i;
#        $maxval = $length[$i];
#    }
#}
        #print "$tokens[$maxpos][0]\n";
        my $token = $tokens[$maxpos][0];
        my $re = $tokens[$maxpos][1];
        $_[0]->YYData->{"DATA"} =~ s/^${re}//;
        #print "$token : $&\n";
        return ($token, $&);
    }
    elsif (!$found && !length($_[0]->YYData->{"DATA"})) {
        return ('', undef);
    }
    else {
        print "unable to parse\n";
        print $_[0]->YYData->{"DATA"}, "\n";
        return ('', undef);
    }
}

sub Lexer {
    my ($type, $value) = getToken($_[0]);
    print "Removed: ( '$type' : '$value' )\n";
    return ($type, $value);
    #return ('', undef);
}

sub printer{
    print "\n";
    my @tokens = @{shift(@_)};
    my @words = @_;
    my $parser = shift(@tokens);
    my $word_string = join("->", @words);
    my $token_string = "$words[0]"."->";
    $token_string .= join("->", @tokens);
    
    print "$word_string\n";
    print "$token_string\n";
    #print "('", $parser->YYCurtok, "': '", $parser->YYCurval, "')\n";
    #print "YYExpect: ", join("\n", $_[0]->YYExpect), "\n";
}
%}

%token '{'

%token WORD PMFUNC STRING /*METHOD FUNCMETH THING PRIVATEREF*/
/*%token FUNC0SUB UNIOPSUB LSTOPSUB*/
/*%token LABEL*/
%token /*FORMAT ANONSUB*/ SUB PACKAGE USE
%token WHILE IF /*UNTIL UNLESS*/ ELSE ELSIF CONTINUE FOR
%token LOOPEX DOTDOT
%token FUNC1 FUNC UNIOP LSTOP /*FUNC0*/
%token RELOP EQOP MULOP ADDOP
%token DOLSHARP /*DO HASHBRACK*/ NOAMP
%token MY /*LOCAL MYSUB*/
/*%token COLONATTR*/

%nonassoc PREC_LOW
%nonassoc LOOPEX

%left OROP
%left ANDOP
%right NOTOP
%nonassoc LSTOP /*LSTOPSUB*/
%left ','
%right ASSIGNOP
/*%right '?' ':'*/
%nonassoc DOTDOT
%left OROR
%left ANDAND
%nonassoc EQOP
%nonassoc RELOP
%nonassoc UNIOP /*UNIOPSUB*/
/* %left SHIFTOP */
%left ADDOP
%left MULOP
%left MATCHOP
%right '!' /*'~'*/ UMINUS /*REFGEN*/
%right POWOP
%nonassoc /*PREINC PREDEC*/ POSTINC POSTDEC
/*%left ARROW*/
%nonassoc ')'
%left '('
%left '[' '{'


%% /* RULES */

/* The whole program */
prog    :    lineseq
            {
                printer(\@_, "prog", "lineseq");
                return "$_[1]";
            }
    ;

/* An ordinary block */
block    :    '{' remember lineseq '}'
            {}
    ;

remember:    /* NULL */    /* start a full lexical scope */
            {}
    ;

mblock    :    '{' mremember lineseq '}'
            {}
    ;

mremember:    /* NULL */    /* start a partial lexical scope */
            {}
    ;

/* A collection of "lines" in the program */
lineseq    :    /* NULL */
            {}
    |    lineseq decl
            {}
    |    lineseq line
            {
                printer(\@_, "lineseq", "lineseq", "line");
                return "$_[1]$_[2]";
            }
    ;

/* A "line" in the program */
line    :    /*label*/ cond
            {}
    |    loop    /* loops add their own labels */
    |    /*label*/ sideff ';'
            {
                printer(\@_, "line", "sideff", "';'");
                return "$_[1]\n";
            }
    |    COMMENT
            {
                printer(\@_, "line", "COMMENT");
                return "$_[1]\n";
            }
    ;

/* An expression which may have a side-effect */
sideff    :    error
            {}
    |    expr
            {
                printer(\@_, "sideff", "expr");
                return $_[1];
            }
            
    |    expr IF expr
            {}
    |    expr WHILE expr
            {}
    |    expr FOR expr
            {}
    ;

/* else and elsif blocks */
else    :    /* NULL */
            {}
    |    ELSE mblock
            {}
    |    ELSIF '(' mexpr ')' mblock else
            {}
    ;

/* Real conditional expressions */
cond    :    IF '(' remember mexpr ')' mblock else
            {}
    ;

/* Continue blocks */
cont    :    /* NULL */
            {}
    |    CONTINUE block
            {}
    ;

/* Loops: while, until, for, and a bare block */
loop    :    /*label*/ WHILE '(' remember mtexpr ')' mblock cont
            {}
    |    /*label*/ FOR MY remember my_scalar '(' mexpr ')' mblock cont
            {}
    |    /*label*/ FOR scalar '(' remember mexpr ')' mblock cont
            {}
    |    /*label*/ FOR '(' remember mexpr ')' mblock cont
            {}
    |    /*label*/ FOR '(' remember mnexpr ';' mtexpr ';' mnexpr ')' mblock
            /* basically fake up an initialize-while lineseq */
            {}
    |    /*label*/ 
        block cont  /* a block is a loop that happens once */
            {}
    ;

/* Normal expression */
nexpr    :    /* NULL */
            {}
    |    sideff
    ;

/* Boolean expression */
texpr    :    /* NULL means true */
            {}
    |    expr
    ;

/* Inverted boolean expression */
/*
iexpr    :    expr
            {}
    ;
*/

/* Expression with its own lexical scope */
mexpr    :    expr
            {}
    ;

mnexpr    :    nexpr
            {}
    ;

mtexpr    :    texpr
            {}
    ;

/* Some kind of declaration - does not take part in the parse tree */
decl    :    format
            {}
    |    subrout
            {}
    |    package
            {}
    |    use
            {}
    ;

/* Subroutine definition */
subrout    :    SUB startsub subname /*proto subattrlist*/ subbody
            {}
    ;

startsub:    /* NULL */    /* start a regular subroutine scope */
            {}
;

/* Name of a subroutine - must be a bareword, could be special */
subname    :    WORD    {}
    ;

/* Subroutine body - either null or a block */
subbody    :    block    {}
    |    ';'    {}
    ;

package :    PACKAGE WORD ';'
            {}
    |    PACKAGE ';'
            {}
    ;

use    :    USE startsub
            {}
            WORD WORD listexpr ';'
            {}
    ;

/* Ordinary expressions; logical combinations */
expr    :    expr ANDOP expr
            {}
    |    expr OROP expr
            {}
    |    argexpr %prec PREC_LOW
    ;

/* Expressions are a list of terms joined by commas */
argexpr    :    argexpr ','
            {
                printer (\@_, "argexpr", "','");
                return "$_[1], ";
            }
    |    argexpr ',' term
            {
                printer (\@_, "argexpr", "','", "term");
                return "$_[1], $_[3]";
            }
    |    term %prec PREC_LOW
            {
                printer (\@_, "argexpr", "term");
                return $_[1];
            }
    ;



/* Some kind of subscripted expression */
subscripted: scalar '[' expr ']'          /* $array[$element] */
            {}
    ;

/* Binary operators between terms */
termbinop    :    term ASSIGNOP term             /* $x = $y */
            {
                printer (\@_, "termbinop", "term", "ASSIGNOP", "term");
                return "$_[1] $_[2] $_[3]";
            }
    |    term POWOP term                        /* $x ** $y */
            {}
    |    term MULOP term                        /* $x * $y, $x x $y */
            {
                printer (\@_, "termbinop", "term", "MULOP", "term");
                return "int($_[1]) $_[2] int($_[3])";
            }
    |    term ADDOP term                        /* $x + $y */
            {
                printer (\@_, "termbinop", "term", "ADDOP", "term");
                return "int($_[1]) $_[2] int($_[3])";
            }
    |    term RELOP term                        /* $x > $y, etc. */
            {}
    |    term EQOP term                         /* $x == $y, $x eq $y */
            {}
    |    term DOTDOT term                       /* $x..$y, $x...$y */
            {}
    |    term ANDAND term                       /* $x && $y */
            {}
    |    term OROR term                         /* $x || $y */
            {}
    |    term MATCHOP term                      /* $x =~ /$y/ */
            {}
    ;

/* Unary operators and terms */
termunop : '-' term %prec UMINUS                       /* -$x */
            {}
    |    '+' term %prec UMINUS                  /* +$x */
            {}
    |    '!' term                               /* !$x */
            {}
    |    term POSTINC                           /* $x++ */
            {}
    |    term POSTDEC                           /* $x-- */
            {}
    ;

term    :    termbinop
    |    termunop
    |    STRING 
            {
                printer (\@_, "term", "STRING");
                return $_[1];
            
            }

    |    myattrterm    %prec UNIOP
            {}
    |    '(' expr ')'
            {}
    |    '(' ')'
            {}
    |    scalar    %prec '('
            {
                printer (\@_, "term", "scalar");
                return $_[1];
            }
    |    hsh     %prec '('
            {}
    |    ary     %prec '('
            {}
    |    arylen     %prec '('                    /* $#x, $#{ something } */
            {}
    |       subscripted
            {}
    |    '(' expr ')' '[' expr ']'            /* list slice */
            {}
    |    '(' ')' '[' expr ']'                 /* empty list slice! */
            {}
    |    ary '[' expr ']'                     /* array slice */
            {}
    |    ary '{' expr ';' '}'                 /* @hash{@keys} */
            {}
    |    amper                                /* &foo; */
            {}
    |    amper '(' ')'                        /* &foo() */
            {}
    |    amper '(' expr ')'                   /* &foo(@args) */
            {}
    |    NOAMP WORD listexpr                  /* foo(@args) */
            {}
    |    LOOPEX  /* loop exiting command (goto, last, dump, etc) */
            {}
    |    NOTOP argexpr                        /* not $foo */
            {}
    |    UNIOP                                /* Unary op, $_ implied */
            {}
    |    UNIOP block                          /* eval { foo }, I *think* */
            {}
    |    UNIOP term                           /* Unary op */
            {}
    |    FUNC1 '(' ')'                        /* not () */
            {}
    |    FUNC1 '(' expr ')'                   /* not($foo) */
            {}
    |    PMFUNC '(' term ')'                  /* split (/foo/) */
            {}
    |    PMFUNC '(' term ',' term ')'         /* split (/foo/,$bar) */
            {}
    |    WORD

    /* list operators */
    |    LSTOP indirob argexpr /* map {...} @args or print $fh @args */
            {
                printer (\@_, "term", "LSTOP", "indirob", "argexpr");
            }
    |    FUNC '(' indirob expr ')'      /* print ($fh @args */
            {}
    |    LSTOP listexpr                       /* print @args */
            {
                printer (\@_, "term", "LSTOP", "listexpr");
                return "print($_[2])";
            
            }
    |    FUNC '(' listexprcom ')'             /* print (@args) */
            {}
    ;

/* "my" declarations, with optional attributes */
myattrterm:    MY myterm myattrlist
            {}
    |    MY myterm
            {}
    ;

/* Things that can be "my"'d */
myterm    :    '(' expr ')'
            {}
    |    '(' ')'
            {}
    |    scalar    %prec '('
            {}
    |    hsh     %prec '('
            {}
    |    ary     %prec '('
            {}
    ;

/* Basic list expressions */
/* list of terms separated by comma's*/
listexpr:    /* NULL */ %prec PREC_LOW
            {print "empty listexpr\n";}
    |    argexpr    %prec PREC_LOW
            {
                printer (\@_, "listexpr", "argexpr");
                return $_[1];
            }
    ;

/*list of expressions separated by commas*/
listexprcom:    /* NULL */
            {}
    |    expr
            {}
    |    expr ','
            {}
    ;

/* A little bit of trickery to make "for my $foo (@bar)" actually be
   lexical */
my_scalar:    scalar
            {}
    ;

amper    :    '&' indirob
            {}
    ;

scalar    :    '$' indirob
            {
                printer (\@_, "scalar", "'\$'", "indirob"); 
                return "$_[2]";
            }
    ;

ary    :    '@' indirob
            {}
    ;

hsh    :    '%' indirob
            {}
    ;

arylen    :    DOLSHARP indirob
            {}
    ;

/* Indirect objects */
indirob    :    WORD
            {
                printer (\@_, "indirob", "WORD");
                return $_[1];
            }
    |    scalar %prec PREC_LOW
            {}
    |    block
            {}
    ;

%%
